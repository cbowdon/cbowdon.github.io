{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Working with (around) proxies\"\n",
        "format: html\n",
        "execute:\n",
        "  enabled: false\n",
        "freeze: true\n",
        "---\n",
        "\n",
        "\n",
        "N.B. This article is ten years old and certainly does not represent best practices in the 2020s.\n",
        "\n",
        "This is something that I seem to have to do on a monthly basis on various projects: a throwaway script that includes getting some resource from the Internet. This means I have to spar with my old nemesis the corporate proxy and her minions, the 407 and the SSL verification error.\n",
        "\n",
        "$DAYJOB uses an authenticated proxy and their own root certificate. It's seamless for Office and IE users because their system is pre-configured. But not for those of us who are spinning up VMs and installing packages and come to think of it almost everything you need to do as a software engineer. (It also can /weaken/ rather than enhance security, the stated aim, but that's an article for another day.)\n",
        "\n",
        "This is a quick guide-by-example for how to authenticated against a proxy and ignore any SSL verification errors in a variety of scripting languages. The examples use only the standard library for a widely available (read: old) version of each language. The assumption is that if you can't reach the Internet, you don't have better packages or newer versions.\n",
        "\n",
        "It is *not* an example of how to write good production software. It is a catalogue of dirty workarounds. You have been warned.\n",
        "\n",
        "## Bash\n",
        "\n",
        "Many applications respect the =$http_proxy= environmental argument, so it's worth setting this in your =.bash_profile=. Those that don't often take command line flags for a proxy and to ignore SSL verification.\n",
        "\n",
        "\n",
        "```{sh}\n",
        "  http_proxy=http://username:password@host:port\n",
        "  export $http_proxy\n",
        "\n",
        "  curl --proxy $http_proxy --insecure --url ... \n",
        "\n",
        "  git -c http.proxy=$http_proxy -c http.sslVerify=false clone ...\n",
        "```\n",
        "\n",
        "\n",
        "## Python 2\n",
        "\n",
        "This works in Python 2.6 and 2.7. In Python 3 the principles are the same but `urllib` has been reorganized.\n"
      ],
      "id": "4daf8d9c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "  import logging\n",
        "  import ssl\n",
        "  import urllib2\n",
        "\n",
        "  logger = logging.getLogger('demo')\n",
        "   \n",
        "  def proxy_opener(http_proxy):\n",
        "      \"\"\"Return an opener that uses the given proxy and ignores SSL certs(!).\n",
        "      Proxy is of the form: http(s)://username:password@host:port\"\"\"\n",
        "      logger.warn('Ignoring SSL certificates')\n",
        "      try:\n",
        "          ctx = ssl.create_default_context()\n",
        "          ctx.check_hostname = False\n",
        "          ctx.verify_mode = ssl.CERT_NONE\n",
        "   \n",
        "          https = urllib2.HTTPSHandler(context=ctx)\n",
        "   \n",
        "      except AttributeError:\n",
        "          logger.debug('Python 2.6 does not support cert verification anyway')\n",
        "          https = urllib2.HTTPSHandler()\n",
        "\n",
        "          proxy = urllib2.ProxyHandler({'http': http_proxy,\n",
        "                                        'https': http_proxy})\n",
        "   \n",
        "      opener = urllib2.build_opener(proxy, https)\n",
        "   \n",
        "      return opener"
      ],
      "id": "a84f7203",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Ruby\n",
        "\n",
        "This is basically a wrapper over `Net::HTTP.start` that pulls the proxy from the usual environment variable and disables SSL validation.\n",
        "\n",
        "Make sure that your Ruby is compiled with OpenSSL support. This definitely works in Ruby 2.3; as far as I can see it will work back to 1.8 but this hasn't been tested.\n",
        "\n",
        "\n",
        "```{ruby}\n",
        "  require 'net/http'\n",
        "  require 'openssl'\n",
        "   \n",
        "  class CorporateProxy\n",
        "   \n",
        "    @@rgx = %r{\n",
        "              https?://  # scheme\n",
        "              (\\w.+)     # user\n",
        "              :(.+)      # pass\n",
        "              @([\\w.-]+) # host\n",
        "              :(\\d+)?    # port\n",
        "            }x\n",
        "   \n",
        "    def self.start(uri, opt, &block)\n",
        "      if not ENV.key?('http_proxy')\n",
        "        raise \"You'll need to define a proxy environment variable to continue.\"\n",
        "      end\n",
        "   \n",
        "      proxy = @@rgx.match(ENV['http_proxy']) do |match|\n",
        "        OpenStruct.new(:user => match[1],\n",
        "                       :pass => match[2],\n",
        "                       :addr => match[3],\n",
        "                       :port => match[4])\n",
        "      end\n",
        "   \n",
        "      Net::HTTP.start(uri.host, uri.port,\n",
        "                      proxy.addr, proxy.port,\n",
        "                      proxy.user, proxy.pass,\n",
        "                      opt.update(:verify_mode => OpenSSL::SSL::VERIFY_NONE),\n",
        "                      &block)\n",
        "    end\n",
        "  end\n",
        "```\n",
        "\n",
        "\n",
        "## Emacs Lisp\n",
        "\n",
        "This works in Emacs 24.5 or newer. I've included an interactive function for setting the proxy password, which I've found to be quite convenient.\n",
        "\n",
        "```{emacs-lisp}\n",
        "  (defconst proxy-host \"example.com\")\n",
        "  (defconst proxy-port 1234)\n",
        "   \n",
        "  (defun make-proxy-url (host port &optional username password)\n",
        "    (concat\n",
        "     (when (or username password)\n",
        "       (format \"%s:%s@\"\n",
        "               (if (not username) \"\" username)\n",
        "               (if (not password) \"\" password)))\n",
        "     (format \"%s:%s\" host port)))\n",
        "   \n",
        "  (defun set-proxy (http-proxy)\n",
        "    \"Set proxy variables that Emacs uses from the provided HTTP-PROXY string.\"\n",
        "    (setenv \"HTTP_PROXY\" (format \"https://%s\" http-proxy))\n",
        "    (setq url-proxy-services (list (cons \"http\" http-proxy)\n",
        "                                   (cons \"https\" http-proxy))))\n",
        "   \n",
        "  (defun set-user-proxy ()\n",
        "    \"Set proxy using current user login name and asking for password.\"\n",
        "    (interactive)\n",
        "    (set-proxy (make-proxy-url proxy-host\n",
        "                               proxy-port\n",
        "                               (user-login-name)\n",
        "                               (read-passwd \"Password: \"))))\n",
        "```"
      ],
      "id": "1d27226b"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}