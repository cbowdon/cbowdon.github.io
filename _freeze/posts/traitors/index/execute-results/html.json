{
  "hash": "f6db473dcfd4b71c305285ea60d03f2c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Can we predict who wins the Traitors with an R simulation?\"\ndate: \"2025-01-19\"\ncategories: [traitors, monte carlo, r]\n---\n\n\n\nThree years in, I am still absolutely hooked on the Traitors (the TV series). Sure, yes, they stretch ten minutes of gameplay into sixty minutes of \"you know I love you, but...\" and the weirdly maddening attempts to make \"yourself\" a polite version of \"you\". And yes, there's massive thumb-shaped groove on the scales because the producers are never going to let the game end early. But all the same, it's such fun watching the players plot and scheme and make terrible, terrible decisions.\n\nOccasionally the show includes contestants who are expert game players. Frankly they tend to underwhelm - with the honourable exception being Kate in Traitors Australia - yet it makes me wonder about optimum strategies. And what's more fun than playing a game? **Making a model of the game in R!**\n\nHere we go, starting with a simple model and building up to more realistic strategies. If you're here just for some insights into the Traitors, you can skip over the code without missing much of the logic.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n#  Plumbing and other irrelevant code is behind the folds.\nlibrary(knitr)\nlibrary(tidyverse)\n\nset.seed(42) # trad\n\norange <- rgb(236 / 255, 137 / 255, 51 / 255)\nmauve <- rgb(89 / 255, 14 / 255, 50 / 255)\n```\n:::\n\n\n\n# Simple model\n\nThe minimum players for Werewolf, a.k.a. Mafia (the game on which Traitors is based) is six, with four villagers and two wolves. In this version of the game there is no recruitment and there are no shields. Let's model this simple version and build up from there. We'll set some basic default strategies for the traitors and the faithful.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngame <- function(\n    n_players = 6,\n    n_traitors = 2,\n    traitor_strategy = random_traitors,\n    faithful_strategy = random_faithful) {\n\n  while (TRUE) {\n\n    # There's an implicit player index:\n    #  c(traitor, traitor, faithful, faithful, ..., faithful)\n\n    # Traitors are always the leading elements in the index, so we can select them with an index range.\n\n    # End-game condition\n    if (n_traitors == 0 || n_players - n_traitors < n_traitors) {\n      break\n    }\n\n    #############\n    # DAY PHASE #\n    #############\n\n    # Traitors and faithfuls update the votes array according to their strategies\n    \n    votes <- rep(0, n_players)\n\n    if (n_players - n_traitors == 1) {\n      # special case for 2 players 1 traitor\n      # coded here to avoid having to handle it repeatedly\n      votes[1:n_traitors] <- n_players\n    } else {\n      votes[1:n_traitors] <- traitor_strategy(n_players, n_traitors)\n    }\n    votes[(n_traitors + 1):n_players] <- faithful_strategy(n_players, n_traitors)\n\n    # Claudia counts the votes\n    banished <- which.max(tabulate(votes))\n\n    n_players <- n_players - 1 # BANISHMENT!\n\n    # If it was a traitor who was banished, decrement\n    if (banished <= n_traitors) {\n      n_traitors <- n_traitors - 1\n    }\n\n    # Check if the game is done yet\n    if (n_traitors == 0 || n_players - n_traitors < n_traitors) {\n      break\n    }\n\n    ###############\n    # NIGHT PHASE #\n    ###############\n    n_players <- n_players - 1 # MURDER!\n  }\n\n  list(n_players_remaining = n_players, n_traitors_remaining = n_traitors)\n}\n\nrandom_faithful <- function(n_players, n_traitors) {\n  # vote for a single random player\n  target <- sample(1:n_players, size = 1)\n  rep(target, n_players - n_traitors)\n}\n\nrandom_traitors <- function(n_players, n_traitors) {\n  # vote a single random faithful\n  target <- sample((n_traitors + 1):n_players, size = 1)\n  rep(target, n_traitors)\n}\n\n# Simulate one random game\ngame()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$n_players_remaining\n[1] 1\n\n$n_traitors_remaining\n[1] 1\n```\n\n\n:::\n:::\n\n\n\nThat's it. All we need to do now is simulate a lot of games and analyse the results. `dplyr` is our friend for this, as usual.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_games <- function(..., .game = game, .n_games = 10000) {\n  1:.n_games |>\n    map(\\(x) .game(...), .progress = TRUE) |>\n    bind_rows() |>\n    mutate(\n      traitors_win = n_traitors_remaining > 0,\n      winner = ifelse(n_traitors_remaining > 0, \"Traitors\", \"Faithful\")\n    )\n}\n\nplot_game_results <- function(results, n_players, n_traitors) {\n  traitor_win_prob <- mean(results$traitors_win)\n\n  ggplot(\n    results |>\n      group_by(winner) |>\n      count()\n  ) +\n    aes(y = winner, x = n, fill = winner, label = winner) +\n    geom_bar(stat = \"identity\", colour = \"black\", orientation = \"y\", alpha = 0.9) +\n    scale_fill_manual(values = c(mauve, orange)) +\n    labs(\n      title = sprintf(\n        \"Game result for %s players, %s traitors. Traitor win prob: %s\",\n        n_players,\n        n_traitors,\n        round(traitor_win_prob, digits = 2)\n      ),\n      x = \"Wins\",\n      y = NULL,\n      fill = \"Winner\"\n    ) +\n    theme_minimal() +\n    theme(aspect.ratio = 0.5)\n}\n\nresults <- sim_games(6, 2)\nplot_game_results(results, 6, 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fig-simulate-games-1.png){#fig-simulate-games width=672}\n:::\n:::\n\n\n\nThat's quite in favour of the traitors, but the picture is different when we change the balance to be the same as the show.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- sim_games(22, 3)\nplot_game_results(results, 22, 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fig-simulate-show-numbers-1.png){#fig-simulate-show-numbers width=672}\n:::\n:::\n\n\n\nNow the game is nearly perfectly balanced.\n\nTo check this simulation is on the right track, I had a little look at a paper on Mafia by [Migdał, 2024](https://arxiv.org/pdf/1009.1031), which includes this formula for traitor winning probability:\n\n$$\np(n, m) \\propto \\frac{m}{\\sqrt{n}}\n$$\n\nWhere $n$ is the number of players, $m$ is the number of traitors, and $p$ is the winning probability.\n\nMigdał calculates the exact probabilities for games with a single traitor and a pseudo-random faithful vote strategy, so we can compare the simulation to the calculation.\n\nThe formula in this case is:\n\n$$\np(n, 1) = \\frac{(n -1)!!}{n!!}\n$$\n\n$n!!$ is the double factorial of $n$, i.e. $1 \\times 3 \\times ... \\times n$ if $n$ is odd and $2 \\times 4 \\times ... \\times n$ if $n$ is even.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmigdal <- function(n) {\n  if (n == 1) {\n    1\n  } else {\n    if (n %% 2 == 0) {\n      prod(seq(1, n - 1, 2)) / prod(seq(2, n, 2))\n    } else {\n      prod(seq(2, n - 1, 2)) / prod(seq(1, n, 2))\n    }\n  }\n}\n\nsim_probs <- 1:20 |>\n  map(\\(n) mean(sim_games(n, 1)$traitors_win), .progress = TRUE) |>\n  as.double()\n\nmigdal_probs <- 1:20 |>\n  map(migdal) |>\n  as.double()\n\nggplot(tibble(n_players = 1:20, sim_prob = sim_probs)) +\n  aes(x = n_players, y = sim_prob) +\n  geom_point(colour = \"red\") +\n  geom_line(data = tibble(n_players = 1:20, migdal_prob = migdal_probs), mapping = aes(y = migdal_prob)) +\n  scale_y_continuous(limits = c(0, 1.5))\n```\n\n::: {.cell-output-display}\n![Comparison of simulated (points) to calculated (line) win probabilities.](index_files/figure-html/fig-sim-comparison-1.png){#fig-sim-comparison width=672}\n:::\n:::\n\n\n\nThe sawtooth pattern is one of the interesting results of Migdał's paper: an odd number of players strongly favours the traitors, to the extent that having 8 faithful and 1 traitor gives the traitor a better win chance than having 3 faithful and 1 traitor, despite there being more than twice as many faithful in the former.\n\nThat has a useful implication for the producers of the Traitors: if they want to keep the game balanced, the timing of adding new players is crucial. I suspect they already know this.\n\n# How good is our random vote assumption?\n\nLet's see how random the votes actually are. Happily, Traitors is a big enough phenomenon that people have recorded the players' votes online. [Here for example](https://thetraitors.fandom.com/wiki/The_Traitors_(Australia)/Season_1#Voting_History) are the votes from Australia's first season. Below the fold is some code for manipulating the copy-pasted votes into a dataframe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Some fixes were required: in Aus two players abstained from a vote, and one quit.\n# I converted these into pseudo-votes for an imaginary player.\n\nvotes <- list(\n  # Aus 1\n  list(\n    c(20, 2, 1),\n    c(16, 2, 1, 1, 1),\n    c(4, 4, 3, 3, 2, 1, 1, 1),\n    c(11, 5, 2),\n    c(7, 6, 2, 1),\n    c(7, 5, 1, 1),\n    c(9, 3, 1),\n    c(9, 1, 1),\n    c(8, 2),\n    c(4, 1, 1, 1, 1),\n    c(5, 1, 1),\n    c(4, 1),\n    c(3, 1),\n    c(2, 1)\n  ),\n\n  # UK 1\n  list(\n    c(11, 8),\n    c(8, 6, 3),\n    c(11, 4),\n    c(9, 4),\n    c(7, 3, 1),\n    c(7, 1, 1),\n    c(6, 2),\n    c(4, 2),\n    c(3, 2),\n    c(1, 3),\n    c(3, 0)\n  ),\n\n  # UK 2\n  list(\n    c(17, 1, 1),\n    c(10, 6, 1),\n    c(7, 6, 2, 1),\n    c(7, 4, 1, 1, 1),\n    c(6, 5, 2, 1),\n    c(7, 3, 2, 1),\n    c(6, 2, 2),\n    c(4, 2, 1, 1),\n    c(4, 2),\n    c(4, 1),\n    c(2, 2),\n    c(3, 1),\n    c(3, 0)\n  ),\n\n  # US\n  list(\n    c(15, 2, 2, 1, 1),\n    c(4, 4, 4, 3, 1, 1, 1, 1),\n    c(7, 6, 3),\n    c(14, 1, 1, 1, 1),\n    c(12, 2, 1, 1),\n    c(7, 3, 2, 1, 1),\n    c(9, 2, 1),\n    c(7, 4),\n    c(6, 2, 1),\n    c(6, 1, 1),\n    c(4, 1, 1),\n    c(4, 1),\n    c(4, 0),\n    c(3, 1),\n    c(1, 2),\n    c(2, 1)\n  )\n)\n\npad <- function(v, new_length, value) {\n  v2 <- rep(value, new_length)\n  v2[1:length(v)] <- v\n  v2\n}\n\nvotes_df <- tibble(v = flatten(votes)) |>\n  rowwise() |>\n  filter(sum(v) > 5) |> # ignore the finals, which are a little different\n  mutate(\n    n_players = sum(v),\n    v = list(pad(v, n_players, 0)), # pad 0s for with each player that didn't receive a vote\n  )\n```\n:::\n\n\n\nWe can guess by looking that these aren't drawn from a uniform distribution, and $\\chi^2$ agrees.\n\n\n\n::: {#tbl-unnecessary-chisq .cell tbl-cap='Completely unnecessary $\\chi^2$ goodness-of-fit tests.'}\n\n```{.r .cell-code}\nvotes_df |>\n  mutate(p.value = chisq.test(v, simulate.p.value = TRUE)[\"p.value\"]) |>\n  unnest(p.value) |>\n  head(5) |>  # the whole table is not that interesting\n  kable(digits = 5)\n```\n\n::: {.cell-output-display}\n\n\n|v                                                                    | n_players| p.value|\n|:--------------------------------------------------------------------|---------:|-------:|\n|20, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 |        23|  0.0005|\n|16, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0       |        21|  0.0005|\n|4, 4, 3, 3, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0              |        19|  0.0085|\n|11, 5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                |        18|  0.0005|\n|7, 6, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                       |        16|  0.0005|\n\n\n:::\n:::\n\n\n\nIt looks to me like the faithful do herd together to whomp one or two unlucky players. Sometimes this is pre-arranged, sometimes it's just groupthink (\"I've just got nothing to go on, so I put yourself...\").\n\nLet's implement a voting strategy that's closer to this reality. We'll take the mean of the vote distributions as the probability of voting for target one, two, three, etc, to form a multinomial distribution, so that our simulation reflects actual vote distributions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_rounds <- nrow(votes_df)\nn_players <- max(votes_df$n_players)\n\nmat <- matrix(0, nrow = n_rounds, ncol = n_players)\n\nfor (i in 1:n_rounds) {\n  v <- votes_df$v[[i]]\n  mat[i, 1:length(v)] <- v / sum(v)\n}\n\nvote_prob <- colSums(mat) / nrow(mat)\n\nbarplot(vote_prob)\n```\n\n::: {.cell-output-display}\n![Mean of normalised vote counts across each round.](index_files/figure-html/fig-est-multinomial-1.png){#fig-est-multinomial width=672}\n:::\n:::\n\n\n\nIn a typical round, we'd expect about 62% of players to vote for player A, and 23% for player B, etc. This doesn't relate to the probability of player A or B being traitors, just the expected vote split.\n\nLet's make that a strategy function and simulate it.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_herd <- function(n_players, n_traitors) {\n  shuffled <- sample(n_players, n_players)\n  sample(shuffled, size = n_players - n_traitors, replace = TRUE, prob = vote_prob[1:n_players])\n}\n\nresults <- sim_games(n_players = 22, n_traitors = 3, traitor_strategy = random_traitors, faithful_strategy = random_herd)\nplot_game_results(results, 22, 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fig-herding-strat-1.png){#fig-herding-strat width=672}\n:::\n:::\n\n\n\nHaving a split vote isn't much worse than the fully random strategy, though it still gives the traitors a slight advantage. Could the faithfuls do better? Well yes, if they were any good at spotting traitors.\n\n# Smarter faithfuls\n\nLet's grant the faithfuls a glimmer of intuition: they are twice as suspicious of traitors as faithfuls, i.e. a traitor is twice as likely to be the vote target as a faithful. We'll call that the _suspicion_ factor, where a value of 1 means a traitor is equally suspicious as any other player to the faithfuls.\n\n We can model this with a suspicion vector, which is the (normalised) level of suspicion for each player. We'll need a new `game` function, which we'll call `game2`. This version of the game allows both faithfuls and traitors to influence the suspicion on each player each day.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngame2 <- function(\n    n_players = 22,\n    n_traitors = 3,\n    traitors_influence = no_influence,\n    faithfuls_influence = no_influence,\n    traitors_strategy = random_traitors2,\n    faithfuls_strategy = random_faithful2) {\n  while (TRUE) {\n\n    if (n_traitors == 0 || n_players - n_traitors < n_traitors) {\n      break\n    }\n\n    #############\n    # DAY PHASE #\n    #############\n\n    # This is the new bit:\n    # traitors and faithfuls influence suspicion\n    suspicions <- rep(1, n_players) |>\n      faithfuls_influence(n_traitors) |>\n      traitors_influence(n_traitors)\n    suspicions <- suspicions / sum(suspicions)  # normalise\n\n    # Voting is as-before\n    votes <- rep(0, n_players)\n\n    if (n_players - n_traitors == 1) {\n      votes[1:n_traitors] <- n_players\n    } else {\n      votes[1:n_traitors] <- traitors_strategy(suspicions, n_players, n_traitors)\n    }\n    votes[(n_traitors + 1):n_players] <- faithfuls_strategy(suspicions, n_players, n_traitors)\n\n    banished <- which.max(tabulate(votes))\n\n    n_players <- n_players - 1 # BANISHMENT!\n    if (banished <= n_traitors) {\n      n_traitors <- n_traitors - 1\n    }\n\n    if (n_traitors == 0 || n_players - n_traitors < n_traitors) {\n      break\n    }\n\n    ###############\n    # NIGHT PHASE #\n    ###############\n    n_players <- n_players - 1 # MURDER!\n  }\n\n  list(n_players_remaining = n_players, n_traitors_remaining = n_traitors)\n}\n\nrandom_faithful2 <- function(suspicions, n_players, n_traitors) {\n  # vote for a single random player\n  target <- sample(1:n_players, size = 1)\n  rep(target, n_players - n_traitors)\n}\n\nrandom_traitors2 <- function(suspicions, n_players, n_traitors) {\n  # as before: vote a single random faithful\n  target <- sample((n_traitors + 1):n_players, size = 1)\n  rep(target, n_traitors)\n}\n\nno_influence <- function(suspicions, n_traitors) suspicions\n```\n:::\n\n\n\nWe set the default influence to be a pass-through i.e. no influence, and set the same default vote strategies as before (adapted to accept but ignore a `suspicions` argument). In that case we see that the game is balanced the same as before. That's a useful sanity check.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- sim_games(.game = game2)\nplot_game_results(results, 22, 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fig-game2-balanced-1.png){#fig-game2-balanced width=672}\n:::\n:::\n\n\n\nWe can check with the random herd strategy too.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_herd2 <- function(suspicion, n_players, n_traitors) {\n  shuffled <- sample(n_players, n_players)\n  sample(shuffled, size = n_players - n_traitors, replace = TRUE, prob = vote_prob[1:n_players])\n}\n\nresults <- sim_games(faithfuls_strategy = random_herd2, .game = game2)\nplot_game_results(results, 22, 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fig-game2-random-herd-1.png){#fig-game2-random-herd width=672}\n:::\n:::\n\n\n\nAlso the same. But now let's grant the faithfuls some strong intuition, twice as much suspicion on traitors as faithfuls. To support different levels of suspicion we can use a closure.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nincreased_suspicion <- function(suspicion_factor) {\n  function(suspicions, n_traitors) {\n    suspicions[1:n_traitors] <- suspicion_factor\n    suspicions\n  }\n}\n\n# e.g. increased_suspicion(2) returns a function that updates the traitors' suspicion values to 2\n```\n:::\n\n\n\nWe also define a version of the herd strategy that selects the players to whomp according to their relative suspicion.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuspicious_herd <- function(suspicions, n_players, n_traitors) {\n  shuffled <- sample(n_players, size = n_players, prob = suspicions)\n  sample(shuffled, size = n_players - n_traitors, replace = TRUE, prob = vote_prob[1:n_players])\n}\n```\n:::\n\n\n\nHow does that shake out for the faithfuls?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- sim_games(faithfuls_influence = increased_suspicion(2), faithfuls_strategy = suspicious_herd, .game = game2)\nplot_game_results(results, 22, 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fig-suspicious-herd-results-1.png){#fig-suspicious-herd-results width=672}\n:::\n:::\n\n\n\nMagnificently! That puts the balance resoundingly in favour of the faithfuls, showing how fragile the traitors' position really is. We can explore how the traitors' win probability depends on how savvy the faithful are.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuspicions <- c(0.5, 1.0, 1.2, 1.5, 2.0, 5.0, 10.0)\ns_df <- suspicions |>\n  map(\n    \\(s)\n    sim_games(\n      n_players = 22,\n      n_traitors = 3,\n      faithfuls_influence = increased_suspicion(s),\n      faithfuls_strategy = suspicious_herd,\n      .game = game2\n    ) |>\n      mutate(suspicion = s),\n    .progress = TRUE\n  ) |>\n  bind_rows() |>\n  group_by(suspicion) |>\n  summarise(traitor_win_prob = mean(traitors_win))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n ■■■■■■■■■■■■■■■■■■■■■■■■■■■       86% |  ETA:  2s\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(s_df) +\n  aes(x = suspicion, y = traitor_win_prob) +\n  geom_area(fill = orange, colour = \"black\") +\n  scale_x_continuous(breaks = seq(0, 10, 1)) +\n  scale_y_continuous(limits = c(0, 1)) +\n  labs(\n    x = \"Suspicion relative to faithful\",\n    y = \"Traitors win probability\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Traitor win probability as a function of suspicion.](index_files/figure-html/fig-suspicion-plot-1.png){#fig-suspicion-plot width=672}\n:::\n:::\n\n\n\nThe odds get exponentially worse the more the faithful suspect the traitors. And vice-versa: if the traitors are less-suspected than the faithful, they stand a strong chance of winning the game.\n\n# Smarter traitors\n\nNaturally the traitors will try to influence faithfuls towards other faithfuls. (Or other traitors, but let's leave _that_ strategy aside for now.) We could model that as the traitors being able to increase the suspicion level of other players. If they have limited influence, perhaps it makes sense for them to make a concerted effort to put suspicion on one other player.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsow_suspicion <- function(suspicion_factor) {\n  function(suspicions, n_traitors) {\n    suspicions[n_traitors + 1] <- suspicion_factor\n    suspicions\n  }\n}\n\nresults <- sim_games(\n  traitors_influence = sow_suspicion(2),\n  faithfuls_influence = increased_suspicion(2),\n  faithfuls_strategy = suspicious_herd,\n  .game = game2\n)\nplot_game_results(results, 22, 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fig-sow-suspicion-1.png){#fig-sow-suspicion width=672}\n:::\n:::\n\n\n\nIt's an improvement! They've dragged the win probability from 0.24 up to 0.32. To completely nullify the faithfuls' advantage though they would need to sow enough suspicion to make the traitors below the group's mean level of suspicion.\n\nHappily for the traitors, the faithfuls seem likely to manage that themselves, by fixating on a \"twinkle in the eye\" or other red herrings. As we've seen, it's enough for the traitors to wait for faithfuls to get suspicious of another faithful and run with that.\n\n# Where next?\n\n> All models are wrong, especially yours Chris.\n>\n> George Box (ghost of)\n\nIt hardly needs to be said that this model is a much-simplified version of reality. We've barely touched on the psychological aspects that make the game so fun, as well as many of the TV's specific game mechanics:\n\n- shields\n- recruitment\n- the final\n\nThose would certainly change the balance. \n\nAt the moment the suspicions vector is also too simplistic. I was tempted to make some kind of model that draws suspicions from a Dirichlet distribution, but decided that making a more complex model to simulate player behaviour that is sometimes almost chaotic is probably not a productive route.\n\nThere's more we could do with the model we have so far too, for example looking at how the traitor win probability increases as the game progresses. For example at the time of writing, the Season 3 in the UK has 8 faithfuls and 2 traitors, with one murder pending. If we repeat the last result with those numbers, the traitors are on-track to win.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- sim_games(\n  n_players = 7,\n  n_traitors = 2,\n  traitors_influence = sow_suspicion(2),\n  faithfuls_influence = increased_suspicion(2),\n  faithfuls_strategy = suspicious_herd,\n  .game = game2\n)\nplot_game_results(results, 7, 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fig-uk-season-3-1.png){#fig-uk-season-3 width=672}\n:::\n:::\n\n\n\nIncidentally, the traitors decided against recruitment. However that would have been an even better move.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- sim_games(\n  n_players = 8,\n  n_traitors = 3,\n  traitors_influence = sow_suspicion(2),\n  faithfuls_influence = increased_suspicion(2),\n  faithfuls_strategy = suspicious_herd,\n  .game = game2\n)\nplot_game_results(results, 8, 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fig-uk-season-3-with-recruitment-1.png){#fig-uk-season-3-with-recruitment width=672}\n:::\n:::\n\n\n\nSomebody better teach those traitors to screw around with code!",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}