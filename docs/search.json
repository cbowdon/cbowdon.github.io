[
  {
    "objectID": "proxy.html",
    "href": "proxy.html",
    "title": "Working with (around) proxies",
    "section": "",
    "text": "N.B. This article is ten years old and certainly does not represent best practices in the 2020s.\nThis is something that I seem to have to do on a monthly basis on various projects: a throwaway script that includes getting some resource from the Internet. This means I have to spar with my old nemesis the corporate proxy and her minions, the 407 and the SSL verification error.\n$DAYJOB uses an authenticated proxy and their own root certificate. It’s seamless for Office and IE users because their system is pre-configured. But not for those of us who are spinning up VMs and installing packages and come to think of it almost everything you need to do as a software engineer. (It also can /weaken/ rather than enhance security, the stated aim, but that’s an article for another day.)\nThis is a quick guide-by-example for how to authenticated against a proxy and ignore any SSL verification errors in a variety of scripting languages. The examples use only the standard library for a widely available (read: old) version of each language. The assumption is that if you can’t reach the Internet, you don’t have better packages or newer versions.\nIt is not an example of how to write good production software. It is a catalogue of dirty workarounds. You have been warned."
  },
  {
    "objectID": "proxy.html#bash",
    "href": "proxy.html#bash",
    "title": "Working with (around) proxies",
    "section": "Bash",
    "text": "Bash\nMany applications respect the =$http_proxy= environmental argument, so it’s worth setting this in your =.bash_profile=. Those that don’t often take command line flags for a proxy and to ignore SSL verification.\n  http_proxy=http://username:password@host:port\n  export $http_proxy\n\n  curl --proxy $http_proxy --insecure --url ... \n\n  git -c http.proxy=$http_proxy -c http.sslVerify=false clone ..."
  },
  {
    "objectID": "proxy.html#python-2",
    "href": "proxy.html#python-2",
    "title": "Working with (around) proxies",
    "section": "Python 2",
    "text": "Python 2\nThis works in Python 2.6 and 2.7. In Python 3 the principles are the same but urllib has been reorganized.\n\n  import logging\n  import ssl\n  import urllib2\n\n  logger = logging.getLogger('demo')\n   \n  def proxy_opener(http_proxy):\n      \"\"\"Return an opener that uses the given proxy and ignores SSL certs(!).\n      Proxy is of the form: http(s)://username:password@host:port\"\"\"\n      logger.warn('Ignoring SSL certificates')\n      try:\n          ctx = ssl.create_default_context()\n          ctx.check_hostname = False\n          ctx.verify_mode = ssl.CERT_NONE\n   \n          https = urllib2.HTTPSHandler(context=ctx)\n   \n      except AttributeError:\n          logger.debug('Python 2.6 does not support cert verification anyway')\n          https = urllib2.HTTPSHandler()\n\n          proxy = urllib2.ProxyHandler({'http': http_proxy,\n                                        'https': http_proxy})\n   \n      opener = urllib2.build_opener(proxy, https)\n   \n      return opener"
  },
  {
    "objectID": "proxy.html#ruby",
    "href": "proxy.html#ruby",
    "title": "Working with (around) proxies",
    "section": "Ruby",
    "text": "Ruby\nThis is basically a wrapper over Net::HTTP.start that pulls the proxy from the usual environment variable and disables SSL validation.\nMake sure that your Ruby is compiled with OpenSSL support. This definitely works in Ruby 2.3; as far as I can see it will work back to 1.8 but this hasn’t been tested.\n  require 'net/http'\n  require 'openssl'\n   \n  class CorporateProxy\n   \n    @@rgx = %r{\n              https?://  # scheme\n              (\\w.+)     # user\n              :(.+)      # pass\n              @([\\w.-]+) # host\n              :(\\d+)?    # port\n            }x\n   \n    def self.start(uri, opt, &block)\n      if not ENV.key?('http_proxy')\n        raise \"You'll need to define a proxy environment variable to continue.\"\n      end\n   \n      proxy = @@rgx.match(ENV['http_proxy']) do |match|\n        OpenStruct.new(:user =&gt; match[1],\n                       :pass =&gt; match[2],\n                       :addr =&gt; match[3],\n                       :port =&gt; match[4])\n      end\n   \n      Net::HTTP.start(uri.host, uri.port,\n                      proxy.addr, proxy.port,\n                      proxy.user, proxy.pass,\n                      opt.update(:verify_mode =&gt; OpenSSL::SSL::VERIFY_NONE),\n                      &block)\n    end\n  end"
  },
  {
    "objectID": "proxy.html#emacs-lisp",
    "href": "proxy.html#emacs-lisp",
    "title": "Working with (around) proxies",
    "section": "Emacs Lisp",
    "text": "Emacs Lisp\nThis works in Emacs 24.5 or newer. I’ve included an interactive function for setting the proxy password, which I’ve found to be quite convenient.\n  (defconst proxy-host \"example.com\")\n  (defconst proxy-port 1234)\n   \n  (defun make-proxy-url (host port &optional username password)\n    (concat\n     (when (or username password)\n       (format \"%s:%s@\"\n               (if (not username) \"\" username)\n               (if (not password) \"\" password)))\n     (format \"%s:%s\" host port)))\n   \n  (defun set-proxy (http-proxy)\n    \"Set proxy variables that Emacs uses from the provided HTTP-PROXY string.\"\n    (setenv \"HTTP_PROXY\" (format \"https://%s\" http-proxy))\n    (setq url-proxy-services (list (cons \"http\" http-proxy)\n                                   (cons \"https\" http-proxy))))\n   \n  (defun set-user-proxy ()\n    \"Set proxy using current user login name and asking for password.\"\n    (interactive)\n    (set-proxy (make-proxy-url proxy-host\n                               proxy-port\n                               (user-login-name)\n                               (read-passwd \"Password: \"))))"
  },
  {
    "objectID": "posts/using-stan-from-r/index.html",
    "href": "posts/using-stan-from-r/index.html",
    "title": "Using Stan from R",
    "section": "",
    "text": "I’ve been trying to get the hang of Bayesian models with Stan. One of the hurdles has been using Stan from R, so in this post I’m jotting down what I’ve learned (mostly the hard way).\n\nRStan or CmdStanR?\nOn the whole I had a much better time using CmdStanR than RStan. When I made a mistake that led to a runtime exception, RStan would simply die with this kind of error:\nError in `unserialize()`:\n! error reading from connection\n     ▆\n  1. └─rstan::stan(...)\n  2.   ├─rstan::sampling(...)\n  3.   └─rstan::sampling(...)\n  4.     └─rstan (local) .local(object, ...)\n  5.       └─parallel::parLapplyLB(cl, X = 1:chains, fun = callFun)\n  6.         ├─base::do.call(...)\n  7.         └─parallel::clusterApplyLB(...)\n  8.           └─parallel:::dynamicClusterApply(cl, fun, length(x), argfun)\n  9.             └─parallel:::recvOneResult(cl)\n 10.               ├─parallel::recvOneData(cl)\n 11.               └─parallel:::recvOneData.SOCKcluster(cl)\n 12.                 └─base::unserialize(socklist[[n]])\nCmdStanR on the other hand would print something useful. Other aspects of the development experience were also nicer:\n\nbetter status updates (e.g. showing when compiling)\neditor support for stan files e.g. linting\n\n\n\nCommon Errors\n\nI got “Rejecting initial value” a lot: “log probability evaluates to log(0), i.e. negative infinity”. This is trying to tell you that the default initial value chosen by Stan has a probability of zero in your prior. You need to set constraints in the parameters block that match the prior distribution you choose. For example if you chose a uniform(1, 10) prior, you should add the constraint &lt;lower=1, upper=10&gt; to your parameter declaration."
  },
  {
    "objectID": "posts/importance-sampling/index.html",
    "href": "posts/importance-sampling/index.html",
    "title": "Importance Sampling example",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4          ✔ readr     2.1.5     \n✔ forcats   1.0.0          ✔ stringr   1.5.1     \n✔ ggplot2   3.5.1          ✔ tibble    3.2.1.9040\n✔ lubridate 1.9.4          ✔ tidyr     1.3.1     \n✔ purrr     1.0.2          \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nset.seed(42)\nThe aim of this post is to teach myself basic Bayesian methods. I’ll set up a toy example problem and solve it.\nLet’s assume we have a natural event that happens with a variable periodicity e.g. a woman’s menstrual cycle. I’m drawing from this excellent blog, but doing a much simpler model because I am but a baby.\nThe aim here is to see if we can find the mean period of the specific woman’s menstrual cycle given some samples and priors for the average cycle. First, priors from the blog linked above:\n# a normal distribution for the mean days between period starts\nprior_mean_mu &lt;- 27.7\nprior_mean_sd &lt;- 2.4\n# a half-normal distribution for the SD of days between period starts\nprior_sd_mu &lt;- 1.6\nprior_sd_sd &lt;- 2.05\nWe will set the true mean and SD (the params, \\(\\theta\\), that we’re looking for) and simulate some sample data, \\(d\\).\ntrue_mu &lt;- 26.3\ntrue_sd &lt;- 1.9\n\nsample_periods &lt;- rnorm(12, true_mu, true_sd)\nFor importance sampling we need a likelihood function, \\(L(d|\\theta)\\). Make the model a normal distribution and this is simply the probability density. We take the log of the likelihood because the numbers could be very small and subject to numerical error.\nlog_likelihood &lt;- function(sample_periods, mean_period, sd_period) {\n  sum(dnorm(sample_periods, mean_period, sd_period, log = TRUE))\n}\nA little sanity check: the likelihood of the true parameters should be greater than the likelihood of the priors.\nlog_likelihood(sample_periods, true_mu, true_sd) &gt; log_likelihood(sample_periods, prior_mean_mu, prior_mean_sd)\n\n[1] FALSE"
  },
  {
    "objectID": "posts/importance-sampling/index.html#importance-sampling-to-fit-the-model",
    "href": "posts/importance-sampling/index.html#importance-sampling-to-fit-the-model",
    "title": "Importance Sampling example",
    "section": "Importance sampling to fit the model",
    "text": "Importance sampling to fit the model\n\nImportance sampling is a Monte Carlo method that is very easy to setup and that can work well if (1) the parameters space is small and (2) the priors are not too dissimilar from the posterior.\n\nI know that both these conditions are true in my toy example.\nFirst we must sample from the prior.\n\nn_samples &lt;- 100000\nprior &lt;- tibble(\n  mu_period = rnorm(n_samples, prior_mean_mu, prior_mean_sd),\n  sd_period = abs(rnorm(n_samples, 0, prior_sd_sd))\n)\n\nggplot(prior) +\n  aes(x = mu_period) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\nggplot(prior) +\n  aes(x = sd_period) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nThen we weight each draw by its likelihood.\n\nweights &lt;- sapply(1:n_samples, function(i) {\n  log_likelihood(sample_periods, prior$mu_period[i], prior$sd_period[i])\n})\n\nThen we resample the prior by this weighting.\n\n# n.b. sample will normalise the weights\nposterior &lt;- prior[sample(n_samples, replace = TRUE, prob = exp(weights)), ]\n\ndf &lt;- bind_rows(\n  mutate(prior, dist = \"prior\"),\n  mutate(posterior, dist = \"posterior\")\n) |&gt;\n  pivot_longer(c(mu_period, sd_period), names_to = \"param\", values_to = \"value\")\n\nggplot(df) +\n  aes(x = value, fill = dist) +\n  facet_wrap(vars(param), scales = \"free\") +\n  geom_histogram(alpha = 0.8, position = \"identity\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nHey Doctor, would you look at that! The posterior is much tighter and closer to the true values.\n\nposterior |&gt; summarise(mu = mean(mu_period), sd = mean(sd_period))\n\n# A tibble: 1 × 2\n     mu    sd\n  &lt;dbl&gt; &lt;dbl&gt;\n1  27.7  1.88\n\n\nHow does that compare to simply taking the mean and SD of the sample data?\n\ntibble(\n    mu = mean(sample_periods),\n    sd = sd(sample_periods)\n)\n\n# A tibble: 1 × 2\n     mu    sd\n  &lt;dbl&gt; &lt;dbl&gt;\n1  27.7  1.75\n\n\nIt’s not highly convincing in this case. I ran this a few times and it seemed that the SD estimation seemed to be closer to the true value than the SD of the sample, but the mean was rarely different. This is probably because it’s a very simple model and importance sampling is rather overkill."
  },
  {
    "objectID": "posts/importance-sampling/index.html#proposal-distribution-isnt-necessarily-the-prior",
    "href": "posts/importance-sampling/index.html#proposal-distribution-isnt-necessarily-the-prior",
    "title": "Importance Sampling example",
    "section": "Proposal distribution isn’t necessarily the prior",
    "text": "Proposal distribution isn’t necessarily the prior\nIn Bååth’s other blog on importance sampling he explains that we are looking at the ratio of the likelihood of getting our sample from the target distribution relative to getting it from the proposal distribution (then normalised to form a new estimate of the target distribution).\nIf the proposal distribution is thinner at the ends than the target distribution, this is suboptimal because we will have fewer samples there. So a T distribution is a useful proposal for a normal target, because it has fatter tails (as controlled by the df degrees of freedom parameter).\nWe could choose a very sloppy proposal like a uniform distribution, but in that case we are suboptimal in terms of how quickly we explore the space. We would have a relatively high number of samples in the tails compared to the peak. Bååth has a neat method of using a Laplacian approximation as a proposal."
  },
  {
    "objectID": "posts/importance-sampling/index.html#aki-another-example",
    "href": "posts/importance-sampling/index.html#aki-another-example",
    "title": "Importance Sampling example",
    "section": "Aki, another example",
    "text": "Aki, another example\nNow an example from this blog post. This one uses a T as the proposal.\n\napprox_samples &lt;- rt(100, df = 3)  # T with 3 deg free is our approximation to posterior\napprox_density &lt;- dt(approx_samples, df = 3, log = TRUE)  # get the prob density for each\nunnormalised_posterior &lt;- dnorm(approx_samples, log = TRUE, sd = sqrt(3))  # convert to actual posterior\n\n# weights are then...\nlog_imp_weights &lt;- unnormalised_posterior - approx_density\ndata.frame(log_imp_weights) %&gt;% \n  ggplot(aes(exp(log_imp_weights))) +\n  geom_density(fill = \"dodgerblue4\", alpha = 0.5) +\n  labs(title = \"Importance weights\",\n       subtitle = \"Approximating a normal with a t distribution\")\n\n\n\n\n\n\n\n# normalise...\nweights &lt;- exp(log_imp_weights) / sum(exp(log_imp_weights))\n\nmean_estimate &lt;- sum(approx_samples * weights)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Using Stan from R\n\n\n\n\n\n\nbayesian\n\n\nr\n\n\nstan\n\n\n\n\n\n\n\n\n\nDec 26, 2024\n\n\nChris Bowdon\n\n\n\n\n\n\n\n\n\n\n\n\nImportance Sampling\n\n\n\n\n\n\nbayesian\n\n\nr\n\n\n\n\n\n\n\n\n\nDec 23, 2024\n\n\nChris Bowdon\n\n\n\n\n\n\nNo matching items"
  }
]